
      <html><head><title>Generator Test</title></head>
      <script>
      function arr_iter(keys)
      {
        this.keys = keys;
        this.cur = 0;
        
        this.next = function() {
          if (this.cur >= this.keys.length) {
            throw StopIteration;
          }
          
          return this.keys[this.cur++];
        }
      }

      __use_Iterator = true;

      function __get_iter(obj)
      {
        if (obj.__proto__.hasOwnProperty("__iterator__") || obj.hasOwnProperty("__iterator__")) {
          return obj.__iterator__();
        } else {
          if (__use_Iterator) {
            return Iterator(obj);
          } else {
            keys = []
            for (var k in obj) {
              keys.push(k)
            }
            return new arr_iter(keys);
          }
        }
      }

      function __get_iter2(obj)
      {
        if (obj.__proto__.hasOwnProperty("__iterator__") || obj.hasOwnProperty("__iterator__")) {
          return obj.__iterator__();
        } else {
          keys = []
          for (var k in obj) {
            keys.push([k, obj[k]])
          }
          return new arr_iter(keys);
        }
      }

      try {
        _tst = Iterator({});
      } catch (Error) {
        __use_Iterator = false;
        Iterator = __get_iter2;
      }
      FrameContinue = {1:1};
      FrameBreak = {2:2};
      "use strict";
var Flags={SELECT: 1, SHADE_SMOOTH: 2, DIRTY: 4, TEMP: 8}
var MeshTypes={VERT: 1, EDGE: 2, LOOP: 4, FACE: 8}
var MeshFlags={USE_MAP_CO: 1, TESS_JOB_FINISHED: 2}
var MeshEvents={RECALC: 1, DESTROY: 2}
function TopoError(msg) {
 Error.call(this, msg);
}
inherit(TopoError, Error);
function Element() {
 this.type = 0;
 this.eid = 0;
 this.gdata = new ElementData();
 this.flag = 0;
 this.index = 0;
}
Element.prototype.toString = function() {
 return "[eid: "+this.eid+", type: "+this.type+"]";
}
Element.prototype.pack = function(data) {
 pack_int(data, this.type);
 pack_int(data, this.eid);
 this.gdata.pack(data);
 pack_int(data, this.flag);
 pack_int(data, this.index);
}
Element.prototype.unpack = function(data, uctx) {
 this.type = unpack_int(data, uctx);
 this.eid = unpack_int(data, uctx);
 this.gdata.unpack(data, uctx);
 this.flag = unpack_int(data, uctx);
 this.index = unpack_int(data, uctx);
}
Element.prototype.__hash__ = function() {
 return String(this.type+"|"+this.eid);
}
function Vertex(co, no) {
 Element.call(this);
 this.type = MeshTypes.VERT;
 this.co = new Vector3(co);
 this.no = new Vector3(no);
 this.td_sco = new Vector3(co);
 this.loop = null;
 this.edges = new GArray();
 this.mapco = new Vector3();
 Object.defineProperty(this, "faces", {get: function() {
  return new MeshIterate(MeshIter.VERT_FACES, this);
 }});
 Object.defineProperty(this, "loops", {get: function() {
  return new MeshIterate(MeshIter.VERT_LOOPS, this);
 }});
}
inherit(Vertex, Element);
Vertex.prototype.pack = function(data) {
 Element.prototype.pack.call(this, data);
 pack_vec3(data, this.co);
 pack_vec3(data, this.no);
 if (this.loop!=null)
  pack_int(data, this.loop.eid);
 else 
  pack_int(data, -1);
 pack_int(data, this.edges.length);
 var __iter_e = __get_iter(this.edges);
 while (1) {
  try {
   var e = __iter_e.next();
   pack_int(data, e.eid);
  }
  catch (_for_err) {
    if (_for_err!==StopIteration) {
      if (_do_iter_err_stacktrace)
       print_stack(_for_err);
      throw _for_err;
      break;
    }
    break;
  }
 }
 pack_vec3(data, this.mapco);
}
Vertex.prototype.unpack = function(data, uctx) {
 Element.prototype.unpack.call(this, data, uctx);
 this.co = unpack_vec3(data, uctx);
 this.no = unpack_vec3(data, uctx);
 this.loop = unpack_int(data, uctx);
 var elen=unpack_int(data, uctx);
 this.edges = new GArray();
 for (var ei=0; ei<elen; ei++) {
   this.edges.push(unpack_int(data, uctx));
 }
 this.mapco = unpack_vec3(data, uctx);
}
Vertex.prototype.recalc_normal = function(redo_face_normals) {
 if (redo_face_normals==undefined)
  redo_face_normals = true;
 this.no.zero();
 var __iter_f = __get_iter(this.faces);
 while (1) {
  try {
   var f = __iter_f.next();
   if (redo_face_normals)
    f.recalc_normal();
   this.no.add(f.no);
  }
  catch (_for_err) {
    if (_for_err!==StopIteration) {
      if (_do_iter_err_stacktrace)
       print_stack(_for_err);
      throw _for_err;
      break;
    }
    break;
  }
 }
 this.no.normalize();
}
function Edge(v1, v2) {
 Element.call(this);
 this.type = MeshTypes.EDGE;
 this.v1 = v1;
 this.v2 = v2;
 this.loop = null;
 Object.defineProperty(this, "totface", {get: function() {
  var l=this.loop;
  if (l==null)
   return 0;
  var i=0;
  do {
   i++;
   l = l.radial_next;
   if (i>10000) {
     console.trace();
     console.log([this._gindex, this.loop.f._gindex, l.f._gindex]);
     console.log([this.loop.index, this.loop.radial_next.index, this.loop.radial_next.radial_prev.index, this.loop.radial_next.radial_next.index]);
     console.log([this.loop.index, this.loop.radial_prev.index, this.loop.radial_prev.radial_prev.index]);
     throw new Error("Mesh integrity error; infinite loop in edge.totface. "+this._gindex);
   }
  } while (l!=this.loop);
  return i;
 }});
 Object.defineProperty(this, "verts", {get: function() {
  return new MeshIterate(MeshIter.EDGE_VERTS, this);
 }});
 Object.defineProperty(this, "loops", {get: function() {
  return new MeshIterate(MeshIter.EDGE_LOOPS, this);
 }});
 Object.defineProperty(this, "faces", {get: function() {
  return new MeshIterate(MeshIter.EDGE_FACES, this);
 }});
}
inherit(Edge, Element);
Edge.prototype.pack = function(data) {
 Element.prototype.pack.call(this, data);
 pack_int(data, this.v1.eid);
 pack_int(data, this.v2.eid);
 if (this.loop!=null)
  pack_int(data, this.loop.eid);
 else 
  pack_int(data, -1);
}
Edge.prototype.unpack = function(data, uctx) {
 Element.prototype.unpack.call(this, data, uctx);
 this.v1 = unpack_int(data, uctx);
 this.v2 = unpack_int(data, uctx);
 this.loop = unpack_int(data, uctx);
}
Edge.prototype.shared_vert = function(e2) {
 if (e2.v1==this.v1||e2.v1==this.v2)
  return e2.v1;
 else 
  if (e2.v2==this.v1||e2.v2==this.v2)
  return e2.v2;
 return null;
}
Edge.prototype.vert_in_edge = function(v) {
 return v==this.v1||v==this.v2;
}
Edge.prototype.other_vert = function(v) {
 if (v==this.v1)
  return this.v2;
 else 
  if (v==this.v2)
  return this.v1;
 else 
  return null;
}
function Loop(v, e, f) {
 Element.call(this);
 this.type = MeshTypes.LOOP;
 this.v = v;
 this.e = e;
 this.f = f;
 this.list = null;
 this.eid = 0;
 this.next = null;
 this.prev = null;
 this.radial_next = null;
 this.radial_prev = null;
}
inherit(Loop, Element);
Loop.prototype.pack = function(data) {
 pack_int(data, this.eid);
 pack_int(data, this.v.eid);
 pack_int(data, this.e.eid);
 pack_int(data, this.radial_next.eid);
 pack_int(data, this.radial_prev.eid);
}
Loop.prototype.unpack = function(data, uctx) {
 this.eid = unpack_int(data, uctx);
 this.v = unpack_int(data, uctx);
 this.e = unpack_int(data, uctx);
 this.radial_next = unpack_int(data, uctx);
 this.radial_prev = unpack_int(data, uctx);
}
Loop.prototype.toSource = function() {
 return "<Loop>";
}
Loop.prototype.__hash__ = function() {
 return String(this.f.eid+"|"+this.type+"|"+this.eid);
}
function LoopIter(looplist) {
 this.list = looplist;
 this.startl = looplist.loop;
 this.cur = this.startl;
 this.next = function() {
  var ret=this.cur;
  if (this.cur==null)
   throw StopIteration;
  this.cur = this.cur.next;
  if (this.cur==this.startl)
   this.cur = null;
  return ret;
 }
}
function LoopList(loop) {
 this.loop = loop;
 this.length = 0;
 this.__iterator__ = function() {
  return new LoopIter(this);
 }
}
var _static_cent=new Vector3();
function Face(looplists) {
 Element.call(this);
 this.type = MeshTypes.FACE;
 this.looplists = looplists;
 this.totvert = 0;
 this.no = new Vector3();
 this.center = new Vector3();
 this.mapcenter = new Vector3();
 for (var i=0; i<looplists.length; i++) {
   var __iter_l = __get_iter(looplists[i]);
   while (1) {
    try {
     var l = __iter_l.next();
     l.f = this;
     l.list = looplists[i];
     this.totvert++;
    }
    catch (_for_err) {
      if (_for_err!==StopIteration) {
        if (_do_iter_err_stacktrace)
         print_stack(_for_err);
        throw _for_err;
        break;
      }
      break;
    }
   }
 }
 Object.defineProperty(this, "loops", {get: function() {
  return new MeshIterate(MeshIter.FACE_ALL_LOOPS, this);
 }});
 Object.defineProperty(this, "bounds", {get: function() {
  return new MeshIterate(MeshIter.FACE_LISTS, this);
 }});
 Object.defineProperty(this, "verts", {get: function() {
  return new MeshIterate(MeshIter.FACE_VERTS, this);
 }});
 Object.defineProperty(this, "edges", {get: function() {
  return new MeshIterate(MeshIter.FACE_EDGES, this);
 }});
}
inherit(Face, Element);
Face.prototype.toSource = function() {
 return "<Face>";
}
Face.prototype.pack = function(data) {
 Element.prototype.pack.call(this, data);
 pack_int(data, this.totvert);
 pack_vec3(data, this.no);
 pack_vec3(data, this.center);
 pack_vec3(data, this.mapcenter);
 pack_int(data, this.looplists.length);
 var __iter_lst = __get_iter(this.looplists);
 while (1) {
  try {
   var lst = __iter_lst.next();
   var i=0;
   var __iter_l = __get_iter(lst);
   while (1) {
    try {
     var l = __iter_l.next();
     i++;
    }
    catch (_for_err) {
      if (_for_err!==StopIteration) {
        if (_do_iter_err_stacktrace)
         print_stack(_for_err);
        throw _for_err;
        break;
      }
      break;
    }
   }
   pack_int(data, i);
   var __iter_l = __get_iter(lst);
   while (1) {
    try {
     var l = __iter_l.next();
     l.pack(data);
    }
    catch (_for_err) {
      if (_for_err!==StopIteration) {
        if (_do_iter_err_stacktrace)
         print_stack(_for_err);
        throw _for_err;
        break;
      }
      break;
    }
   }
  }
  catch (_for_err) {
    if (_for_err!==StopIteration) {
      if (_do_iter_err_stacktrace)
       print_stack(_for_err);
      throw _for_err;
      break;
    }
    break;
  }
 }
}
Face.prototype.unpack = function(data, uctx) {
 Element.prototype.unpack.call(this, data, uctx);
 this.totvert = unpack_int(data, uctx);
 this.no = unpack_vec3(data, uctx);
 this.center = unpack_vec3(data, uctx);
 this.mapcenter = unpack_vec3(data, uctx);
 var lstlen=unpack_int(data, uctx);
 this.looplists = new GArray();
 for (var i=0; i<lstlen; i++) {
   var loop=new LoopList();
   this.looplists.push(loop);
   var looplen=unpack_int(data, uctx);
   var firstloop, prevloop;
   for (var j=0; j<looplen; j++) {
     var l=new Loop();
     l.f = this;
     l.list = loop;
     l.unpack(data, uctx);
     if (j>0) {
       l.prev = prevloop;
       prevloop.next = l;
     }
     prevloop = l;
     if (j==0)
      firstloop = l;
   }
   firstloop.prev = prevloop;
   prevloop.next = firstloop;
   loop.loop = firstloop;
   loop.length = looplen;
 }
}
var _frn_n1=new Vector3();
Face.prototype.recalc_normal = function() {
 var n=null;
 _static_cent[0] = _static_cent[1] = _static_cent[2] = 0.0;
 var __iter_v = __get_iter(this.verts);
 while (1) {
  try {
   var v = __iter_v.next();
   _static_cent.add(v.co);
  }
  catch (_for_err) {
    if (_for_err!==StopIteration) {
      if (_do_iter_err_stacktrace)
       print_stack(_for_err);
      throw _for_err;
      break;
    }
    break;
  }
 }
 _static_cent.divideScalar(this.totvert);
 this.center.load(_static_cent);
 if (this.totvert==3) {
   var l=this.looplists[0].loop;
   var n=normal_tri(l.v.co, l.next.v.co, l.next.next.v.co);
 }
 else 
  if (this.totvert==4) {
   var l=this.looplists[0].loop;
   var n=normal_quad(l.v.co, l.next.v.co, l.next.next.v.co, l.next.next.next.v.co);
 }
 else {
  var l=this.looplists[0].loop;
  var firstl=l;
  var n=_frn_n1;
  n.zero();
  do {
   n.add(normal_tri(l.v.co, l.next.v.co, _static_cent));
   l = l.next;
  } while (l!=firstl);
  n.normalize();
 }
 n.normalize();
 this.no.load(n);
}
function EIDGen() {
 this.cur_eid = 1;
 this.set_cur = function(cur) {
  this.cur_eid = Math.ceil(cur);
 }
 this.max_cur = function(cur) {
  this.cur_eid = Math.max(Math.ceil(cur)+1, this.cur_eid);
 }
 this.get_cur = function(cur) {
  return this.cur_eid;
 }
 this.gen_eid = function() {
  return this.cur_eid++;
 }
}
function GeoArrayIter(arr) {
 this.cur = 0;
 this.arr = arr;
 this.reset = function() {
  this.cur = 0;
 }
 this.next = function() {
  var cur=this.cur;
  var len=this.arr.arr.length;
  var arr=this.arr.arr;
  while (cur!=len&&(arr[cur]==undefined)) {
   cur++;
  }
  if (cur==len) {
    this.reset();
    throw StopIteration;
  }
  else {
   this.cur = cur+1;
   return arr[cur];
  }
 }
}
function AllTypesSelectIter(mesh) {
 this.type = MeshTypes.VERT;
 this.mesh = mesh;
 this.iter = undefined;
 this.__iterator__ = function() {
  return this;
 }
 this.reset = function() {
  this.type = MeshTypes.VERT;
  this.iter = undefined;
 }
 this.next = function() {
  if (this.iter==undefined) {
    this.iter = this.mesh.verts.selected.__iterator__();
  }
  try {
   var next=this.iter.next();
   return next;
  }
  catch (_error) {
    if (_error!=StopIteration) {
      throw _error;
    }
    else {
     if (this.type==MeshTypes.VERT) {
       this.type = MeshTypes.EDGE;
       this.iter = this.mesh.edges.selected.__iterator__();
       return this.next();
     }
     else 
      if (this.type==MeshTypes.EDGE) {
       this.type = MeshTypes.FACE;
       this.iter = this.mesh.faces.selected.__iterator__();
       return this.next();
     }
     else {
      this.reset();
      throw StopIteration;
     }
    }
  }
 }
}
function GeoArray(type, idgen, eidmap) {
 this.arr = new Array();
 this.length = 0;
 this.idgen = idgen;
 this.type = type;
 this.global_eidmap = eidmap;
 this.highlight = null;
 this.freelist = new GArray();
 this.iter = new GeoArrayIter(this);
 this.eidmap = {}
 this._totsel = 0;
 this.__iterator__ = function() {
  if (this.iter.cur!=0)
   return new GeoArrayIter(this);
  else 
   return this.iter;
 }
 this._selected = {}
 Object.defineProperty(this, "selected", {get: function() {
  return new obj_value_iter(this._selected);
 }});
 Object.defineProperty(this, "totsel", {get: function() {
  return this._totsel;
 }});
 this.select = function(e, state) {
  if (e==undefined) {
    console.trace();
    console.log("Selection error");
    return;
  }
  if (state==undefined)
   state = true;
  if (e.type!=this.type) {
    console.trace();
    throw new Error("Passed in wrong type to GeoArray.select! src: "+e.type+" this.type "+this.type);
  }
  if (state) {
    if (!(e.flag&Flags.SELECT)) {
      e.flag|=Flags.SELECT;
      this._selected[e.__hash__()] = e;
      this._totsel++;
    }
  }
  else {
   if ((e.flag&Flags.SELECT)) {
     e.flag&=~Flags.SELECT;
     delete this._selected[e.__hash__()];
     this._totsel--;
   }
  }
 }
 this.get = function(eid) {
  var e=this.eidmap[eid];
  if (e!=undefined&&e.type!=this.type) {
    console.log("Tried to fetch eid of type "+e.type+"from GeoArray of type "+this.type+".");
    console.trace();
    return undefined;
  }
  return e;
 }
 this.push = function(item, set_eid) {
  if (item.flag&Flags.SELECT) {
    item.flag&=~Flags.SELECT;
    this.select(item, true);
  }
  if (set_eid==undefined)
   set_eid = true;
  if (set_eid) {
    item.eid = this.idgen.gen_eid();
  }
  else {
   this.idgen.max_cur(item.eid);
  }
  this.eidmap[item.eid] = item;
  this.global_eidmap[item.eid] = item;
  if (this.freelist.length>0) {
    var idx=this.freelist.pop();
    if (this.arr[idx]!=undefined) {
      console.log("Corrupted freelist in GeoArray.push()!");
      console.trace();
    }
    item._gindex = idx;
    this.arr[idx] = item;
    this.length+=1;
    return;
  }
  item._gindex = this.arr.length;
  this.arr.push(item);
  this.length+=1;
 }
 this.index_update = function() {
  var i=0;
  var __iter_item = __get_iter(this);
  while (1) {
   try {
    var item = __iter_item.next();
    item.index = i++;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
 }
 this.remove = function(item) {
  this.select(item, false);
  if (this.highlight==item)
   this.highlight = null;
  delete this.eidmap[item.eid];
  delete this.global_eidmap[item.eid];
  this.arr[item._gindex] = undefined;
  this.freelist.push(item._gindex);
  item._gindex = -1;
  this.length-=1;
 }
}
function CountIter(iter) {
 var i=0;
 var __iter_item = __get_iter(iter);
 while (1) {
  try {
   var item = __iter_item.next();
   i++;
  }
  catch (_for_err) {
    if (_for_err!==StopIteration) {
      if (_do_iter_err_stacktrace)
       print_stack(_for_err);
      throw _for_err;
      break;
    }
    break;
  }
 }
 return i;
}
function FaceVertIter(data) {
 this.data = data;
 this.curlist = 0;
 this.curloop = data.looplists[0].loop;
 this.startloop = data.looplists[0].loop;
 this.next = function() {
  if (this.curloop==null)
   throw StopIteration;
  var ret=this.curloop.v;
  this.curloop = this.curloop.next;
  if (this.curloop==this.startloop) {
    this.curloop = null;
    this.curlist++;
    if (this.curlist<this.data.looplists.length) {
      this.curloop = this.startloop = this.data.looplists[this.curlist].loop;
    }
  }
  return ret;
 }
}
function FaceLoopIter(data) {
 this.data = data;
 this.curlist = 0;
 this.curloop = data.looplists[0].loop;
 this.startloop = data.looplists[0].loop;
 this.next = function() {
  if (this.curloop==null)
   throw StopIteration;
  var ret=this.curloop;
  this.curloop = this.curloop.next;
  if (this.curloop==this.startloop) {
    this.curloop = null;
    this.curlist++;
    if (this.curlist<this.data.looplists.length) {
      this.curloop = this.startloop = this.data.looplists[this.curlist].loop;
    }
  }
  return ret;
 }
}
function FaceEdgeIter(data) {
 this.data = data;
 this.curlist = 0;
 this.curloop = data.looplists[0].loop;
 this.startloop = data.looplists[0].loop;
 this.next = function() {
  if (this.curloop==null)
   throw StopIteration;
  var ret=this.curloop.e;
  this.curloop = this.curloop.next;
  if (this.curloop==this.startloop) {
    this.curloop = null;
    this.curlist++;
    if (this.curlist<this.data.looplists.length) {
      this.curloop = this.startloop = this.data.looplists[this.curlist].loop;
    }
  }
  return ret;
 }
}
function VertEdgeIter(data) {
 this.data = data;
 this.first = data;
 this.cur = 0;
 this.next = function() {
  if (this.cur<this.data.edges.length()) {
    return this.data.edges[this.cur++];
  }
  else {
   throw StopIteration;
  }
 }
}
function VertLoopIter(data) {
 this.data = data;
 this.first = data;
 this.cur = 0;
 this.startloop = data.loop;
 this.curedge = 0;
 if (data.edges.length!=0)
  this.curloop = data.edges[0].loop;
 else 
  this.curloop = null;
 this.next = function() {
  var ret=null;
  if (this.curloop==null) {
    throw StopIteration;
  }
  ret = this.curloop;
  if (ret.v!=this.data)
   ret = ret.next;
  this.curloop = this.curloop.radial_next;
  if (this.curloop==this.data.edges[this.curedge].loop) {
    this.curedge+=1;
    if (this.curedge!=this.data.edges.length)
     this.curloop = this.data.edges[this.curedge].loop;
    else 
     this.curloop = null;
  }
  return ret;
 }
}
function VertFaceIter(data) {
 this.data = data;
 this.first = data;
 this.cur = 0;
 this.startloop = data.loop;
 this.curedge = 0;
 if (data.edges.length!=0)
  this.curloop = data.edges[0].loop;
 else 
  this.curloop = null;
 this.next = function() {
  if (this.curedge==this.data.edges.length||this.curloop==null) {
    throw StopIteration;
  }
  var ret=this.curloop.f;
  this.curloop = this.curloop.radial_next;
  if (this.curloop==this.data.edges[this.curedge].loop) {
    this.curedge+=1;
    if (this.curedge!=this.data.edges.length)
     this.curloop = this.data.edges[this.curedge].loop;
  }
  return ret;
 }
}
function EdgeVertIter(data) {
 this.data = data;
 this.i = 0;
 this.next = function() {
  if (this.i==0) {
    this.i++;
    return this.data.v1;
  }
  else 
   if (this.i==1) {
    this.i++;
    return this.data.v2;
  }
  else {
   this.i = 0;
   throw StopIteration;
  }
 }
 this.reset = function() {
  this.i = 0;
 }
}
function EdgeFaceIter(data) {
 this.data = data;
 this.first = data;
 this.cur = 0;
 this.curloop = data.loop;
 this.next = function() {
  if (this.curloop==null) {
    throw StopIteration;
  }
  var ret=this.curloop.f;
  this.curloop = this.curloop.radial_next;
  if (this.curloop==this.data.loop) {
    this.curloop = null;
  }
  return ret;
 }
}
function EdgeLoopIter(data) {
 this.data = data;
 this.first = data;
 this.cur = 0;
 this.curloop = data.loop;
 this.next = function() {
  if (this.curloop==null) {
    throw StopIteration;
  }
  var ret=this.curloop;
  this.curloop = this.curloop.radial_next;
  if (this.curloop==this.data.loop) {
    this.curloop = null;
  }
  return ret;
 }
}
var MeshIter={}
MeshIter.VERT_EDGES = 5;
MeshIter.VERT_FACES = 6;
MeshIter.EDGE_FACES = 7;
MeshIter.EDGE_LOOPS = 8;
MeshIter.FACE_VERTS = 9;
MeshIter.FACE_EDGES = 10;
MeshIter.FACE_ALL_LOOPS = 11;
MeshIter.EDGE_VERTS = 12;
function MeshIterate(type, data) {
 this.type = type;
 this.data = data;
 this.flag = 0;
 this.__iterator__ = function() {
  if (this.type==MeshIter.FACE_VERTS)
   return new FaceVertIter(this.data);
  else 
   if (this.type==MeshIter.VERT_EDGES)
   return new VertEdgeIter(this.data);
  else 
   if (this.type==MeshIter.VERT_FACES)
   return new VertFaceIter(this.data);
  else 
   if (this.type==MeshIter.VERT_LOOPS)
   return new VertLoopIter(this.data);
  else 
   if (this.type==MeshIter.EDGE_FACES)
   return new EdgeFaceIter(this.data);
  else 
   if (this.type==MeshIter.EDGE_LOOPS)
   return new EdgeLoopIter(this.data);
  else 
   if (this.type==MeshIter.FACE_EDGES)
   return new FaceEdgeIter(this.data);
  else 
   if (this.type==MeshIter.FACE_ALL_LOOPS)
   return new FaceLoopIter(this.data);
  else 
   if (this.type==MeshIter.EDGE_VERTS)
   return new EdgeVertIter(this.data);
 }
}
var _mesh_id_gen=0;
function Mesh() {
 this.ops = new MeshOpAPI(this);
 this._id = _mesh_id_gen++;
 this.idgen = new EIDGen();
 this.eidmap = {}
 Object.defineProperty(this, "selected", {get: function() {
  return new AllTypesSelectIter(this);
 }});
 this.verts = new GeoArray(MeshTypes.VERT, this.idgen, this.eidmap);
 this.edges = new GeoArray(MeshTypes.EDGE, this.idgen, this.eidmap);
 this.faces = new GeoArray(MeshTypes.FACE, this.idgen, this.eidmap);
 this.vdata = new GeoDataLayout();
 this.edata = new GeoDataLayout();
 this.ldata = new GeoDataLayout();
 this.fdata = new GeoDataLayout();
 this.event_users = new hashtable();
 this.name = "";
 this.materials = new GArray();
 this.looptris = new GArray();
 this.render = 0;
 this.api = new MeshAPI(this);
 this.__hash__ = function() {
  return "Mesh"+this._id;
 }
 this.remove_callback = function(owner) {
  this.event_users.remove(owner);
 }
 this.update_callback = function(owner, callback) {
  this.event_users.set(owner, callback);
 }
 this.gen_partial = function(geom, expandlvl) {
  var vset=new set();
  var eset=new set();
  var fset=new set();
  var test_vset=new set();
  var __iter_e = __get_iter(geom);
  while (1) {
   try {
    var e = __iter_e.next();
    if (e.type==MeshTypes.VERT) {
      vset.add(e);
      var __iter_e2 = __get_iter(e.edges);
      while (1) {
       try {
        var e2 = __iter_e2.next();
        var __iter_l = __get_iter(e2.loops);
        while (1) {
         try {
          var l = __iter_l.next();
          eset.add(l.e);
          fset.add(l.f);
         }
         catch (_for_err) {
           if (_for_err!==StopIteration) {
             if (_do_iter_err_stacktrace)
              print_stack(_for_err);
             throw _for_err;
             break;
           }
           break;
         }
        }
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
    }
    else 
     if (e.type==MeshTypes.EDGE) {
      eset.add(e);
      test_vset.add(e.v1);
      test_vset.add(e.v2);
      var __iter_f = __get_iter(e.faces);
      while (1) {
       try {
        var f = __iter_f.next();
        if (!fset.has(f)) {
          var __iter_v = __get_iter(f.verts);
          while (1) {
           try {
            var v = __iter_v.next();
            test_vset.add(v);
           }
           catch (_for_err) {
             if (_for_err!==StopIteration) {
               if (_do_iter_err_stacktrace)
                print_stack(_for_err);
               throw _for_err;
               break;
             }
             break;
           }
          }
        }
        fset.add(f);
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
    }
    else 
     if (e.type==MeshTypes.FACE) {
      fset.add(e);
      var f=e;
      var __iter_v = __get_iter(f.verts);
      while (1) {
       try {
        var v = __iter_v.next();
        test_vset.add(v);
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
    }
    else {
     throw new Error("Invalid element type "+e.type+"!");
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_f = __get_iter(fset);
  while (1) {
   try {
    var f = __iter_f.next();
    var __iter_e = __get_iter(f.edges);
    while (1) {
     try {
      var e = __iter_e.next();
      var found=false;
      var __iter_f2 = __get_iter(e.faces);
      while (1) {
       try {
        var f2 = __iter_f2.next();
        if (!fset.has(f2)) {
          found = true;
          break;
        }
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
      if (!found) {
        if (!eset.has(e)) {
          eset.add(e);
          test_vset.add(e.v1);
          test_vset.add(e.v2);
        }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_v = __get_iter(test_vset);
  while (1) {
   try {
    var v = __iter_v.next();
    if (vset.has(v))
     continue;
    var i=0, c=0;
    var __iter_e = __get_iter(v.edges);
    while (1) {
     try {
      var e = __iter_e.next();
      c+=eset.has(e) ? 1 : 0;
      i++;
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    if (i==c) {
      vset.add(v);
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  for (var i=0; i<expandlvl; i++) {
    var vset2=new set();
    var __iter_v = __get_iter(vset);
    while (1) {
     try {
      var v = __iter_v.next();
      var __iter_e = __get_iter(v.edges);
      while (1) {
       try {
        var e = __iter_e.next();
        var __iter_l = __get_iter(e.loops);
        while (1) {
         try {
          var l = __iter_l.next();
          vset2.add(l.v);
          eset.add(l.e);
          fset.add(l.f);
          var __iter_l2 = __get_iter(l.f.loops);
          while (1) {
           try {
            var l2 = __iter_l2.next();
            vset2.add(l2.v);
            eset.add(l2.e);
           }
           catch (_for_err) {
             if (_for_err!==StopIteration) {
               if (_do_iter_err_stacktrace)
                print_stack(_for_err);
               throw _for_err;
               break;
             }
             break;
           }
          }
         }
         catch (_for_err) {
           if (_for_err!==StopIteration) {
             if (_do_iter_err_stacktrace)
              print_stack(_for_err);
             throw _for_err;
             break;
           }
           break;
         }
        }
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    var __iter_v = __get_iter(vset2);
    while (1) {
     try {
      var v = __iter_v.next();
      vset.add(v);
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
  }
  var __iter_v = __get_iter(vset);
  while (1) {
   try {
    var v = __iter_v.next();
    var __iter_e = __get_iter(v.edges);
    while (1) {
     try {
      var e = __iter_e.next();
      var __iter_l = __get_iter(v.loops);
      while (1) {
       try {
        var l = __iter_l.next();
        eset.add(l.e);
        fset.add(l.f);
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var data=[];
  pack_int(data, vset.length);
  var __iter_v = __get_iter(vset);
  while (1) {
   try {
    var v = __iter_v.next();
    v.pack(data);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  pack_int(data, eset.length);
  var __iter_e = __get_iter(eset);
  while (1) {
   try {
    var e = __iter_e.next();
    e.pack(data);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  pack_int(data, fset.length);
  var __iter_f = __get_iter(fset);
  while (1) {
   try {
    var f = __iter_f.next();
    f.pack(data);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  data = new DataView(new Uint8Array(data).buffer);
  var veids=list(vset);
  var eeids=list(eset);
  var feids=list(fset);
  for (var i=0; i<veids.length; i++) {
    veids[i] = veids[i].eid;
  }
  for (var i=0; i<eeids.length; i++) {
    eeids[i] = eeids[i].eid;
  }
  for (var i=0; i<feids.length; i++) {
    feids[i] = feids[i].eid;
  }
  var max_eid=this.idgen.get_cur();
  var obj={v_eids: veids, e_eids: eeids, f_eids: feids, max_eid: max_eid, data: data, eidgen: this.idgen.get_cur()}
  return obj;
 }
 this.load_partial = function(part) {
  var __iter_f = __get_iter(part.f_eids);
  while (1) {
   try {
    var f = __iter_f.next();
    f = this.faces.get(f);
    if (f==undefined)
     continue;
    if (f.type!=MeshTypes.FACE) {
      console.log("YEEK!");
      throw "Invalid f eid type"+f;
    }
    this.kill_face(f);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_e = __get_iter(part.e_eids);
  while (1) {
   try {
    var e = __iter_e.next();
    e = this.edges.get(e);
    if (e==undefined)
     continue;
    if (e.type!=MeshTypes.EDGE) {
      console.log("YEEK!");
      throw "Invalid e eid type"+e;
    }
    this.kill_edge(e);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_v = __get_iter(part.v_eids);
  while (1) {
   try {
    var v = __iter_v.next();
    v = this.verts.get(v);
    if (v==undefined)
     continue;
    if (v.type!=MeshTypes.VERT) {
      console.log("YEEK!");
      throw "Invalid v eid type"+v;
    }
    this.kill_vert(v);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var last_e=this.idgen.get_cur();
  var eidmap=this.eidmap;
  for (var eid=part.max_eid; eid<last_e; eid++) {
    var e=eidmap[eid];
    if (e==undefined)
     continue;
    this.kill(e);
  }
  var idgen=this.idgen;
  idgen.set_cur(part.eidgen);
  var data=part.data;
  var uctx=new unpack_ctx();
  var newvs=new set();
  var verts=new GArray();
  var edges=new GArray();
  var faces=new GArray();
  var totv=unpack_int(data, uctx);
  for (var i=0; i<totv; i++) {
    var v=new Vertex();
    v.unpack(data, uctx);
    newvs.add(v.eid);
    verts.push(v);
  }
  var tote=unpack_int(data, uctx);
  for (var i=0; i<tote; i++) {
    var e=new Edge();
    e.unpack(data, uctx);
    edges.push(e);
  }
  var loops={}
  var loops2={}
  var totf=unpack_int(data, uctx);
  for (var i=0; i<totf; i++) {
    var f=new Face([]);
    f.unpack(data, uctx);
    faces.push(f);
    var __iter_list = __get_iter(f.looplists);
    while (1) {
     try {
      var list = __iter_list.next();
      var __iter_l = __get_iter(list);
      while (1) {
       try {
        var l = __iter_l.next();
        l.list = list;
        l.f = f;
        loops[l.eid] = l;
        loops2[l.eid] = l;
        idgen.max_cur(l.eid);
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
  }
  var __iter_v = __get_iter(verts);
  while (1) {
   try {
    var v = __iter_v.next();
    this.verts.push(v, false);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_e = __get_iter(edges);
  while (1) {
   try {
    var e = __iter_e.next();
    this.edges.push(e, false);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var i=0;
  var __iter_f = __get_iter(faces);
  while (1) {
   try {
    var f = __iter_f.next();
    this.faces.push(f, false);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_f = __get_iter(this.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    var __iter_list = __get_iter(f.looplists);
    while (1) {
     try {
      var list = __iter_list.next();
      var __iter_l = __get_iter(list);
      while (1) {
       try {
        var l = __iter_l.next();
        loops[l.eid] = l;
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var c=0;
  var __iter_f = __get_iter(faces);
  while (1) {
   try {
    var f = __iter_f.next();
    var __iter_list = __get_iter(f.looplists);
    while (1) {
     try {
      var list = __iter_list.next();
      var __iter_l = __get_iter(list);
      while (1) {
       try {
        var l = __iter_l.next();
        l.e = eidmap[l.e];
        l.v = eidmap[l.v];
        l.radial_next = null;
        l.radial_prev = null;
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_e = __get_iter(edges);
  while (1) {
   try {
    var e = __iter_e.next();
    e.v1 = eidmap[e.v1];
    e.v2 = eidmap[e.v2];
    if (!newvs.has(e.v1.eid))
     e.v1.edges.push(e);
    if (!newvs.has(e.v2.eid))
     e.v2.edges.push(e);
    e.loop = null;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_v = __get_iter(verts);
  while (1) {
   try {
    var v = __iter_v.next();
    var elen=v.edges.length;
    for (var i=0; i<elen; i++) {
      v.edges[i] = eidmap[v.edges[i]];
    }
    v.loop = null;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_f = __get_iter(faces);
  while (1) {
   try {
    var f = __iter_f.next();
    var __iter_list = __get_iter(f.looplists);
    while (1) {
     try {
      var list = __iter_list.next();
      var __iter_l = __get_iter(list);
      while (1) {
       try {
        var l = __iter_l.next();
        this._radial_loop_insert(l.e, l);
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
 }
 this.regen_positions = function() {
  this.render.recalc|=RecalcFlags.REGEN_COS;
  this.do_callbacks(MeshEvents.RECALC);
 }
 this.regen_normals = function() {
  this.render.recalc|=RecalcFlags.REGEN_NORS;
  this.do_callbacks(MeshEvents.RECALC);
 }
 this.do_callbacks = function(event) {
  var __iter_k = __get_iter(this.event_users);
  while (1) {
   try {
    var k = __iter_k.next();
    this.event_users.get(k)(k, this, event);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
 }
 this.regen_render = function() {
  this.render.recalc|=RecalcFlags.REGEN_NORS|RecalcFlags.REGEN_TESS|RecalcFlags.REGEN_COS|RecalcFlags.REGEN_COLORS;
  var __iter_f = __get_iter(this.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    f.flag|=Flags.DIRTY;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  this.do_callbacks(MeshEvents.RECALC);
 }
 this.regen_colors = function() {
  this.render.recalc|=RecalcFlags.REGEN_COLORS;
  this.do_callbacks(MeshEvents.RECALC);
 }
 this.copy = function() {
  var m2=new Mesh();
  m2.render = new render();
  m2.render.vertprogram = this.render.vertprogram;
  m2.render.drawprogram = this.render.drawprogram;
  this.verts.index_update();
  this.edges.index_update();
  this.faces.index_update();
  var verts=new GArray();
  var __iter_v = __get_iter(this.verts);
  while (1) {
   try {
    var v = __iter_v.next();
    var v2=m2.make_vert(v.co, v.no);
    m2.copy_vert_data(v2, v, true);
    verts.push(v2);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_e = __get_iter(this.edges);
  while (1) {
   try {
    var e = __iter_e.next();
    var e2=m2.make_edge(verts[e.v1.index], verts[e.v2.index], false);
    m2.copy_edge_data(e2, e, true);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_f = __get_iter(this.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    var vlists=new GArray();
    var __iter_list = __get_iter(f.looplists);
    while (1) {
     try {
      var list = __iter_list.next();
      var loop=new GArray();
      var __iter_l = __get_iter(list);
      while (1) {
       try {
        var l = __iter_l.next();
        loop.push(verts[l.v.index]);
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
      vlists.push(loop);
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    var f2=m2.make_face_complex(vlists);
    m2.copy_face_data(f2, f, true);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  return m2;
 }
 this.pack = function(data) {
  pack_int(data, this.verts.length);
  var __iter_v = __get_iter(this.verts);
  while (1) {
   try {
    var v = __iter_v.next();
    v.pack(data);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  pack_int(data, this.edges.length);
  var __iter_e = __get_iter(this.edges);
  while (1) {
   try {
    var e = __iter_e.next();
    e.pack(data);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  pack_int(data, this.faces.length);
  var __iter_f = __get_iter(this.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    f.pack(data);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
 }
 this.unpack = function(data, uctx) {
  var vlen=unpack_int(data, uctx);
  console.log("vlen: ", vlen);
  var loops={}
  var eidmap=this.eidmap;
  for (var i=0; i<vlen; i++) {
    var v=new Vertex();
    v.unpack(data, uctx);
    this.verts.push(v, false);
  }
  var elen=unpack_int(data, uctx);
  console.log("elen: ", elen);
  for (var i=0; i<elen; i++) {
    var e=new Edge();
    e.unpack(data, uctx);
    this.edges.push(e, false);
    e.v1 = eidmap[e.v1];
    e.v2 = eidmap[e.v2];
  }
  var flen=unpack_int(data, uctx);
  console.log("flen: ", flen);
  for (var i=0; i<flen; i++) {
    var f=new Face([]);
    f.unpack(data, uctx);
    var __iter_lst = __get_iter(f.looplists);
    while (1) {
     try {
      var lst = __iter_lst.next();
      var __iter_l = __get_iter(lst);
      while (1) {
       try {
        var l = __iter_l.next();
        l.v = eidmap[l.v];
        l.e = eidmap[l.e];
        l.f = f;
        l.list = lst;
        loops[l.eid] = l;
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    this.faces.push(f, false);
  }
  var __iter_v = __get_iter(this.verts);
  while (1) {
   try {
    var v = __iter_v.next();
    for (var i=0; i<v.edges.length; i++) {
      v.edges[i] = eidmap[v.edges[i]];
    }
    if (v.loop!=-1)
     v.loop = loops[v.loop];
    else 
     v.loop = null;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_e = __get_iter(this.edges);
  while (1) {
   try {
    var e = __iter_e.next();
    if (e.loop!=-1)
     e.loop = loops[e.loop];
    else 
     e.loop = null;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_f = __get_iter(this.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    var __iter_lst = __get_iter(f.looplists);
    while (1) {
     try {
      var lst = __iter_lst.next();
      var __iter_l = __get_iter(lst);
      while (1) {
       try {
        var l = __iter_l.next();
        l.radial_next = loops[l.radial_next];
        l.radial_prev = loops[l.radial_prev];
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
 }
 this.shallow_copy = function() {
  var m=new Mesh();
  m.verts = this.verts;
  m.faces = this.faces;
  m.edges = this.edges;
  m.name = this.name;
  m.materials = this.materials;
  m.looptris = this.looptris;
  m.render = this.render;
  m.render.recalc = true;
  m.ops = this.ops;
  m.vdata = this.vdata;
  m.edata = this.edata;
  m.ldata = this.ldata;
  m.fdata = this.fdata;
  return m;
 }
 this.find_edge = function(v1, v2) {
  var __iter_e = __get_iter(v1.edges);
  while (1) {
   try {
    var e = __iter_e.next();
    if (e.vert_in_edge(v2)) {
      if (!e.vert_in_edge(v1)) {
        console.trace();
        throw new Error("Mesh integrity error");
        return null;
      }
      return e;
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  return null;
 }
 this.make_vert = function(co, no) {
  var v=new Vertex(co, no);
  this.vdata.element_init(v.gdata);
  this.verts.push(v);
  return v;
 }
 this.make_edge = function(v1, v2, check) {
  if (check==undefined)
   check = true;
  if (v1==v2) {
    throw new Error("Cannot make edge from one vert only");
  }
  if (check) {
    var e=this.find_edge(v1, v2);
    if (e!=null) {
      if (e._gindex==-1)
       throw new Error("Mesh integrity error; find_edge returned a deleted ghost edge");
      return e;
    }
  }
  var e=new Edge(v1, v2);
  if (e.v1.edges==undefined||e.v2.edges==undefined) {
    console.trace();
  }
  e.v1.edges.push(e);
  e.v2.edges.push(e);
  this.edata.element_init(e.gdata);
  this.edges.push(e);
  return e;
 }
 this._radial_loop_insert = function(e, l) {
  if (e.loop==null) {
    l.radial_next = l.radial_prev = l;
    e.loop = l;
  }
  else {
   l.radial_next = e.loop.radial_next;
   l.radial_prev = e.loop;
   e.loop.radial_next.radial_prev = l;
   e.loop.radial_next = l;
  }
  if (e.v1.loop==null)
   e.v1.loop = l;
  if (e.v2.loop==null)
   e.v2.loop = l;
 }
 this._radial_loop_remove = function(e, l) {
  if (l.f==l.v.loop.f) {
    var l2=l;
    do {
     l2 = l2.radial_next;
     if (l2.v==l.v&&l2.f!=l.f)
      break;
    } while (l2!=l);
    if (l2.f==l.f) {
      l.v.loop = null;
      var __iter_e2 = __get_iter(l.v.edges);
      while (1) {
       try {
        var e2 = __iter_e2.next();
        if (e2!=l.e&&e2.loop!=null&&e2.loop.f!=l.f) {
          l.v.loop = e2.loop;
          break;
        }
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
    }
    else {
     l.v.loop = l2;
    }
  }
  if (e.loop==null) {
    console.log("Mesh integrity error; e.loop is null");
    console.trace();
  }
  if (e.loop.f==l.f) {
    var i=0;
    do {
     e.loop = e.loop.radial_next;
     if (e.loop.f!=l.f)
      break;
     i++;
     if (i>2000) {
       throw new Error("Mesh integrity error in Mesh._radial_loop_remove()");
     }
    } while (e.loop.f!=l.f);
  }
  if (e.loop.f==l.f)
   e.loop = null;
  l.radial_prev.radial_next = l.radial_next;
  l.radial_next.radial_prev = l.radial_prev;
 }
 this.find_face = function(verts) {
  var v1=verts[0];
  var __iter_f = __get_iter(v1.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    if (f.totvert!=verts.length)
     continue;
    var vset=new set(list(f.verts));
    var found=true;
    for (var i=0; i<verts.length; i++) {
      var v=verts[i];
      if (!vset.has(v)) {
        found = false;
        break;
      }
    }
    if (found) {
      return f;
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  return null;
 }
 this.make_face = function(verts, check_exist) {
  if (check_exist==undefined)
   check_exist = false;
  var loops=new LoopList(null);
  var list=new GArray();
  var vset=new set();
  for (var i=0; i<verts.length; i++) {
    if (vset.has(verts[i])) {
      console.trace();
      throw "Tried to pass in duplicate verts to non-complex make_face";
    }
    vset.add(verts[i]);
  }
  if (check_exist) {
    var f=this.find_face(verts);
    if (f!=null)
     return f;
  }
  var lprev=null, lstart=null;
  for (var i=0; i<verts.length; i++) {
    var v1=verts[i];
    var v2=verts[(i+1)%verts.length];
    var e=this.make_edge(v1, v2, true);
    var l=new Loop(v1, e);
    l.list = loops;
    this.ldata.element_init(l.gdata);
    if (lprev!=null) {
      l.prev = lprev;
      lprev.next = l;
    }
    if (lstart==null)
     lstart = l;
    l.e = e;
    l.eid = this.idgen.gen_eid();
    this._radial_loop_insert(e, l);
    lprev = l;
  }
  lprev.next = lstart;
  lstart.prev = lprev;
  loops.loop = lstart;
  loops.length = verts.length;
  list.push(loops);
  var f=new Face(list);
  this.fdata.element_init(f.gdata);
  this.faces.push(f);
  return f;
 }
 this.make_face_complex = function(vertlists, check_exist) {
  if (check_exist==undefined)
   check_exist = false;
  if (check_exist) {
    var vlist=new GArray();
    for (var i=0; i<vertlists.length; i++) {
      for (var j=0; j<vertlists[i].length; j++) {
        vlist.push(vertlists[i][j]);
      }
    }
    var f=this.find_face(vlist);
    if (f!=null)
     return f;
  }
  var vset=new set();
  var list=new GArray();
  var totvert=0;
  for (var j=0; j<vertlists.length; j++) {
    var verts=vertlists[j];
    var loops=new LoopList(null);
    if (verts.length==0) {
      console.log("Tried to create face with empty boundary loops");
      console.log(j);
      console.trace();
      return null;
    }
    var lprev=null, lstart=null;
    for (var i=0; i<verts.length; i++) {
      var v1=verts[i];
      var v2=verts[(i+1)%verts.length];
      if (vset.has(v1)) {
        console.trace();
        console.log("Warning: duplicate verts in make_face_complex");
      }
      vset.add(v1);
      var e=this.make_edge(v1, v2, true);
      var l=new Loop(v1, e);
      l.eid = this.idgen.gen_eid();
      l.list = loops;
      totvert++;
      this.ldata.element_init(l.gdata);
      if (lprev) {
        lprev.next = l;
        l.prev = lprev;
      }
      if (lstart==null)
       lstart = l;
      if (v1.loop==null)
       v1.loop = l;
      this._radial_loop_insert(e, l);
      lprev = l;
    }
    lprev.next = lstart;
    lstart.prev = lprev;
    loops.loop = lstart;
    loops.length = verts.length;
    list.push(loops);
  }
  if (totvert==0) {
    console.log("Tried to create empty face");
    return null;
  }
  var f=new Face(list);
  this.fdata.element_init(f.gdata);
  this.faces.push(f);
  return f;
 }
 this.kill = function(e) {
  if (e.type==MeshTypes.VERT)
   this.kill_vert(e);
  else 
   if (e.type==MeshTypes.EDGE)
   this.kill_edge(e);
  else 
   if (e.type==MeshTypes.FACE)
   this.kill_face(e);
  else 
   throw "Invalid element type "+e.type+" in Mesh.kill()";
 }
 this.kill_vert = function(v) {
  if (v._gindex==-1) {
    console.trace();
    console.log("Tried to kill an already-removed vert!");
    return;
  }
  var killedges=list(v.edges);
  var __iter_e = __get_iter(killedges);
  while (1) {
   try {
    var e = __iter_e.next();
    this.kill_edge(e);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  this.verts.remove(v);
 }
 this.kill_edge = function(e) {
  if (e._gindex==-1) {
    console.log("Tried to kill an already-removed edge!");
    console.trace();
    return;
  }
  var killfaces=list(e.faces);
  var __iter_f = __get_iter(killfaces);
  while (1) {
   try {
    var f = __iter_f.next();
    this.kill_face(f);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  e.v1.edges.remove(e);
  e.v2.edges.remove(e);
  this.edges.remove(e);
 }
 this.kill_face = function(f) {
  if (f._gindex==-1) {
    console.trace();
    throw new Error("Tried to kill an already-removed face!"+f.eid);
    return;
  }
  var __iter_looplist = __get_iter(f.looplists);
  while (1) {
   try {
    var looplist = __iter_looplist.next();
    var __iter_l = __get_iter(looplist);
    while (1) {
     try {
      var l = __iter_l.next();
      this._radial_loop_remove(l.e, l);
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  this.faces.remove(f);
 }
 this.copy_vert_data = function(dest, src, copy_eid) {
  this.verts.select(dest, src.flag&Flags.SELECT);
  if (copy_eid==undefined)
   copy_eid = false;
  dest.flag = src.flag;
  dest.index = src.index;
  if (copy_eid)
   this._set_eid(dest, this.verts, src.eid);
  this.vdata.copy(dest.gdata, src.gdata);
 }
 this.copy_edge_data = function(dest, src, copy_eid) {
  this.edges.select(dest, src.flag&Flags.SELECT);
  if (copy_eid==undefined)
   copy_eid = false;
  dest.flag = src.flag;
  dest.index = src.index;
  if (copy_eid)
   this._set_eid(dest, this.edges, src.eid);
  this.edata.copy(dest.gdata, src.gdata);
 }
 this.copy_loop_data = function(dest, src, copy_eid) {
  if (copy_eid==undefined)
   copy_eid = false;
  dest.flag = src.flag;
  dest.index = src.index;
  if (copy_eid)
   dest.eid = src.eid;
  this.ldata.copy(dest.gdata, src.gdata);
 }
 this._set_eid = function(e, elements, eid) {
  delete elements.eidmap[e.eid];
  e.eid = eid;
  elements.eidmap[eid] = e;
  if (elements.idgen.cur_eid<=eid)
   elements.idgen.cur_eid = eid+1;
 }
 this.copy_face_data = function(dest, src, copy_eid) {
  this.faces.select(dest, src.flag&Flags.SELECT);
  if (copy_eid==undefined)
   copy_eid = false;
  dest.flag = src.flag;
  dest.index = src.index;
  if (copy_eid)
   this._set_eid(dest, this.faces, src.eid);
  dest.no.load(src.no);
  dest.center.load(src.center);
  this.fdata.copy(dest.gdata, src.gdata);
 }
 this.select = function(element, mode) {
  if (element.type==MeshTypes.VERT) {
    this.verts.select(element, mode);
  }
  else 
   if (element.type==MeshTypes.EDGE) {
    this.edges.select(element, mode);
  }
  else 
   if (element.type==MeshTypes.FACE) {
    this.faces.select(element, mode);
  }
  else {
   console.log("Invalid element passed into Mesh.select()");
   console.trace();
  }
 }
 this.error = function(msg) {
  console.log(msg);
 }
}
var _cent=new Vector3();
var _mapi_frn_n1=new Vector3();
function recalc_normals_job(m2, use_sco) {
 this.iter = new recalc_normals_job_intern(m2, use_sco);
 this.i = 0;
 this.__iterator__ = function() {
  return this;
 }
 this.next = function() {
  this.iter.next();
  this.i++;
  if (this.i>5000) {
    console.log("Inifite loop detected in recalc normals job!");
    throw StopIteration;
  }
 }
}
function recalc_normals_job_intern(m2, use_sco) {
 this.scope = {v_38: undefined, f_14: undefined, i_11: undefined, use_sco_0: use_sco, __iter_f_11: undefined, cent_1: undefined, n_14: undefined, m2_0: m2, __iter_v_1: undefined, _for_err_39: undefined}
 this.__iterator__ = function() {
  return this;
 }
 this.frame_0 = function(scope) {
  if (this.first) {
  }
  return [46, undefined];
 }
 this.frame_1 = function(scope) {
  scope.cent_1=new Vector3();
  scope.__iter_v_1 = __get_iter(scope.m2_0.verts);
  return [2, undefined];
 }
 this.frame_2 = function(scope) {
  if (!1) {
    return [11, undefined];
  }
  return [3, undefined];
 }
 this.frame_3 = function(scope) {
  this.trystack.push([5, "_for_err_5"]);
  return [4, undefined];
 }
 this.frame_4 = function(scope) {
  scope.v_4 = scope.__iter_v_1.next();
  scope.v_4.no[0] = scope.v_4.no[1] = scope.v_4.no[2] = 0.0;
  return [2, undefined];
 }
 this.frame_5 = function(scope) {
  return [6, undefined];
 }
 this.frame_6 = function(scope) {
  if (!(scope._for_err_5!==StopIteration)) {
    return [10, undefined];
  }
  else {
   return [7, undefined];
  }
  return [7, undefined];
 }
 this.frame_7 = function(scope) {
  if (!(_do_iter_err_stacktrace)) {
    return [9, undefined];
  }
  else {
   return [8, undefined];
  }
  return [8, undefined];
 }
 this.frame_8 = function(scope) {
  print_stack(scope._for_err_5);
  return [9, undefined];
 }
 this.frame_9 = function(scope) {
  throw scope._for_err_5;
  return [11, undefined];
  return [10, undefined];
 }
 this.frame_10 = function(scope) {
  return [11, undefined];
  return [2, undefined];
 }
 this.frame_11 = function(scope) {
  scope.i_11=0;
  scope.__iter_f_11 = __get_iter(scope.m2_0.faces);
  return [12, undefined];
 }
 this.frame_12 = function(scope) {
  if (!1) {
    return [35, undefined];
  }
  return [13, undefined];
 }
 this.frame_13 = function(scope) {
  this.trystack.push([29, "_for_err_29"]);
  return [14, undefined];
 }
 this.frame_14 = function(scope) {
  scope.f_14 = scope.__iter_f_11.next();
  scope.n_14=null;
  scope.i_11+=1;
  return [15, undefined];
 }
 this.frame_15 = function(scope) {
  if (!(scope.i_11%20==0)) {
    return [17, undefined];
  }
  else {
   return [16, undefined];
  }
  return [16, undefined];
 }
 this.frame_16 = function(scope) {
  return [17, [1]];
 }
 this.frame_17 = function(scope) {
  if (!(scope.i_11>80000)) {
    return [19, undefined];
  }
  else {
   return [18, undefined];
  }
  return [18, undefined];
 }
 this.frame_18 = function(scope) {
  console.log("Infinite loop");
  console.trace();
  return [35, undefined];
  return [19, undefined];
 }
 this.frame_19 = function(scope) {
  scope.f_14.recalc_normal();
  scope.__iter_v_1 = __get_iter(scope.f_14.verts);
  return [20, undefined];
 }
 this.frame_20 = function(scope) {
  if (!1) {
    return [12, undefined];
  }
  return [21, undefined];
 }
 this.frame_21 = function(scope) {
  this.trystack.push([23, "_for_err_23"]);
  return [22, undefined];
 }
 this.frame_22 = function(scope) {
  scope.v_22 = scope.__iter_v_1.next();
  scope.v_22.no.add(scope.f_14.no);
  this.trystack.pop();
  return [20, undefined];
 }
 this.frame_23 = function(scope) {
  return [24, undefined];
 }
 this.frame_24 = function(scope) {
  if (!(scope._for_err_23!==StopIteration)) {
    return [28, undefined];
  }
  else {
   return [25, undefined];
  }
  return [25, undefined];
 }
 this.frame_25 = function(scope) {
  if (!(_do_iter_err_stacktrace)) {
    return [27, undefined];
  }
  else {
   return [26, undefined];
  }
  return [26, undefined];
 }
 this.frame_26 = function(scope) {
  print_stack(scope._for_err_23);
  return [27, undefined];
 }
 this.frame_27 = function(scope) {
  throw scope._for_err_23;
  return [12, undefined];
  return [28, undefined];
 }
 this.frame_28 = function(scope) {
  return [12, undefined];
  return [20, undefined];
 }
 this.frame_29 = function(scope) {
  return [30, undefined];
 }
 this.frame_30 = function(scope) {
  if (!(scope._for_err_29!==StopIteration)) {
    return [34, undefined];
  }
  else {
   return [31, undefined];
  }
  return [31, undefined];
 }
 this.frame_31 = function(scope) {
  if (!(_do_iter_err_stacktrace)) {
    return [33, undefined];
  }
  else {
   return [32, undefined];
  }
  return [32, undefined];
 }
 this.frame_32 = function(scope) {
  print_stack(scope._for_err_29);
  return [33, undefined];
 }
 this.frame_33 = function(scope) {
  throw scope._for_err_29;
  return [35, undefined];
  return [34, undefined];
 }
 this.frame_34 = function(scope) {
  return [35, undefined];
  return [12, undefined];
 }
 this.frame_35 = function(scope) {
  scope.__iter_v_1 = __get_iter(scope.m2_0.verts);
  return [36, undefined];
 }
 this.frame_36 = function(scope) {
  if (!1) {
    return [45, undefined];
  }
  return [37, undefined];
 }
 this.frame_37 = function(scope) {
  this.trystack.push([39, "_for_err_39"]);
  return [38, undefined];
 }
 this.frame_38 = function(scope) {
  scope.v_38 = scope.__iter_v_1.next();
  scope.v_38.no.normalize();
  return [36, undefined];
 }
 this.frame_39 = function(scope) {
  return [40, undefined];
 }
 this.frame_40 = function(scope) {
  if (!(scope._for_err_39!==StopIteration)) {
    return [44, undefined];
  }
  else {
   return [41, undefined];
  }
  return [41, undefined];
 }
 this.frame_41 = function(scope) {
  if (!(_do_iter_err_stacktrace)) {
    return [43, undefined];
  }
  else {
   return [42, undefined];
  }
  return [42, undefined];
 }
 this.frame_42 = function(scope) {
  print_stack(scope._for_err_39);
  return [43, undefined];
 }
 this.frame_43 = function(scope) {
  throw scope._for_err_39;
  return [45, undefined];
  return [44, undefined];
 }
 this.frame_44 = function(scope) {
  return [45, undefined];
  return [36, undefined];
 }
 this.frame_45 = function(scope) {
  scope.m2_0.regen_normals();
  scope.m2_0.regen_positions();
  return [46, undefined];
 }
 this.frames = [this.frame_0, this.frame_1, this.frame_2, this.frame_3, this.frame_4, this.frame_5, this.frame_6, this.frame_7, this.frame_8, this.frame_9, this.frame_10, this.frame_11, this.frame_12, this.frame_13, this.frame_14, this.frame_15, this.frame_16, this.frame_17, this.frame_18, this.frame_19, this.frame_20, this.frame_21, this.frame_22, this.frame_23, this.frame_24, this.frame_25, this.frame_26, this.frame_27, this.frame_28, this.frame_29, this.frame_30, this.frame_31, this.frame_32, this.frame_33, this.frame_34, this.frame_35, this.frame_36, this.frame_37, this.frame_38, this.frame_39, this.frame_40, this.frame_41, this.frame_42, this.frame_43, this.frame_44, this.frame_45];
 this.cur = 1;
 this.trystack = new Array();
 this.next = function() {
  var ret;
  while (this.cur<this.frames.length) {
   try {
    ret = this.frames[this.cur].call(this, this.scope);
   }
   catch (_generator_error) {
     if (this.trystack.length>0) {
       var ts1=this.trystack.pop();
       this.scope[ts1[1]] = _generator_error;
       ret = [ts1[0], undefined];
     }
     else {
      throw _generator_error;
     }
   }
   if (ret[0]==this.frames.length) {
     throw StopIteration;
     break;
   }
   if (ret[0]==this.cur) {
     console.trace();
     console.log("YEEK!");
     throw StopIteration;
   }
   this.cur = ret[0];
   if (ret[1]!=undefined) {
     return ret[1][0];
   }
  }
 }
}
create_prototype(recalc_normals_job);
recalc_normals_job.jobtype = new recalc_normals_job();
function MeshAPI(mesh) {
 this.mesh = mesh;
 this.recalc_normals = function() {
  var k=0;
  var m2=this.mesh;
  var cent=new Vector3();
  var __iter_v = __get_iter(m2.verts);
  while (1) {
   try {
    var v = __iter_v.next();
    v.no[0] = v.no[1] = v.no[2] = 0.0;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_f = __get_iter(m2.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    f.recalc_normal();
    var __iter_v = __get_iter(f.verts);
    while (1) {
     try {
      var v = __iter_v.next();
      v.no.add(f.no);
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_v = __get_iter(m2.verts);
  while (1) {
   try {
    var v = __iter_v.next();
    v.no.normalize();
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
 }
 this.split_edge = function(e, t) {
  var m=this.mesh;
  var co=new Vector3(e.v2.co).sub(e.v1.co);
  co.mulScalar(t);
  co.add(e.v1.co);
  var nv=m.make_vert(co);
  var ne=m.make_edge(nv, e.v2, false);
  m.copy_vert_data(nv, e.v1);
  var loops=list(e.loops);
  var __iter_l = __get_iter(loops);
  while (1) {
   try {
    var l = __iter_l.next();
    m._radial_loop_remove(e, l);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var v1=e.v1, v2=e.v2;
  e.v2.edges.remove(e);
  e.v2 = nv;
  nv.edges.push(e);
  var __iter_l = __get_iter(loops);
  while (1) {
   try {
    var l = __iter_l.next();
    var l2=new Loop(nv, ne, l.f);
    l2.eid = m.idgen.gen_eid();
    l2.list = l.list;
    l.list.length++;
    l.f.totvert++;
    if (l.v==v1&&l.next.v==v2) {
      l.next.prev = l2;
      l2.next = l.next;
      l.next = l2;
      l2.prev = l;
      m._radial_loop_insert(e, l);
      m._radial_loop_insert(ne, l2);
    }
    else 
     if (l.v==v2&&l.next.v==v1) {
      l.next.prev = l2;
      l2.next = l.next;
      l.next = l2;
      l2.prev = l;
      m._radial_loop_insert(e, l2);
      m._radial_loop_insert(ne, l);
    }
    else {
     console.log("yeek!!");
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  if (e.loop)
   v1.loop = e.loop;
  if (ne.loop)
   v2.loop = ne.loop;
  m.copy_edge_data(ne, e);
  return [nv, ne];
 }
 this.get_face_zmatrix = function(f) {
  var axis=new Vector3();
  var cross=new Vector3();
  axis.zero();
  axis[2] = 1.0;
  cross.load(f.no);
  cross.cross(axis);
  cross.normalize();
  var sign=axis.dot(f.no)>0.0 ? 1.0 : -1.0;
  var a=Math.acos(Math.abs(f.no.dot(axis)));
  var q=new Quat();
  q.axisAngleToQuat(cross, sign*a);
  var mat=q.toMatrix();
  return mat;
 }
 this._split_face_array = [];
 this._split_face_v1 = new Vector3();
 this._split_face_v2 = new Vector3();
 this._split_face_cent = new Vector3();
 this._split_face_max = new Vector3();
 this._split_face_c1 = new Vector3();
 this._split_face_c2 = new Vector3();
 this.split_face = function(f, v1, v2) {
  var m=this.mesh;
  var l1=null, l2=null;
  if (v1==v2) {
    console.log("Cannot split face; need more than one input verts");
  }
  if (m.find_edge(v1, v2)!=null) {
    console.log("Cannot split face; edge already exists between v1 and v2");
    return null;
  }
  var __iter_l = __get_iter(v1.loops);
  while (1) {
   try {
    var l = __iter_l.next();
    if (l.f==f&&l.v==v1) {
      l1 = l;
      break;
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_l = __get_iter(v2.loops);
  while (1) {
   try {
    var l = __iter_l.next();
    if (l.f==f&&l.v==v2) {
      l2 = l;
      break;
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  if (l1==null||l2==null) {
    console.trace();
    console.log("split_face: Verts not in face!");
    return null;
  }
  var cos=this._split_face_array;
  var c=0;
  var mat=this.get_face_zmatrix(f);
  var co1=this._split_face_v1.load(v1.co);
  var co2=this._split_face_v1.load(v2.co);
  co1.multVecMatrix(mat);
  co1[2] = 0.0;
  co2.multVecMatrix(mat);
  co2[2] = 0.0;
  var __iter_list1 = __get_iter(f.looplists);
  while (1) {
   try {
    var list1 = __iter_list1.next();
    var __iter_l = __get_iter(list1);
    while (1) {
     try {
      var l = __iter_l.next();
      if (c>=cos.length)
       cos.push(new Vector3());
      cos[c].load(l.v.co);
      cos[c].multVecMatrix(mat);
      cos[c][2] = 0.0;
      for (var i=0; i<3; i++) {
        cos[c][i]+=(Math.random()-0.5)*1e-05;
      }
      c++;
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var c=0;
  var __iter_list1 = __get_iter(f.looplists);
  while (1) {
   try {
    var list1 = __iter_list1.next();
    var l=list1.loop;
    do {
     if (l.e.vert_in_edge(v1)||l.e.vert_in_edge(v2)) {
       c++;
       l = l.next;
       continue;
     }
     if (line_line_cross([co1, co2], [cos[c], cos[c+1]])) {
       console.log("split_face: Invalid selection");
       return null;
     }
     c++;
     l = l.next;
    } while (l!=list1.loop.prev);
    c++;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  if (l1.list==l2.list) {
    var points=new GArray();
    var cent=this._split_face_cent.zero();
    var i;
    var i1=-1, i2=-1;
    var lco1, lco2;
    c = 0;
    var __iter_list1 = __get_iter(f.looplists);
    while (1) {
     try {
      var list1 = __iter_list1.next();
      i = 0;
      var __iter_l = __get_iter(list1);
      while (1) {
       try {
        var l = __iter_l.next();
        if (list1===l1.list) {
          points.push(cos[c]);
          cent.add(cos[c]);
          if (l==l1) {
            i1 = i;
            lco1 = cos[c];
          }
          else 
           if (l==l2) {
            i2 = i;
            lco2 = cos[c];
          }
        }
        i++;
        c++;
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    cent.divideScalar(i);
    var wind=get_boundary_winding(points);
    var lv1, lv2;
    if (i1>i2) {
      var t=l1;
      l1 = l2;
      l2 = t;
      t = lco1;
      lco1 = lco2;
      lco2 = t;
    }
    var c1=this._split_face_c1;
    var c2=this._split_face_c2;
    var max=this._split_face_max.zero();
    var maxd=-1;
    var w=0;
    var totw=0;
    var l3=l2.prev;
    while (l3!=l1) {
     cent.load(l3.v.co);
     cent.multVecMatrix(mat);
     cent[2] = 0.0;
     c1.load(cent).sub(lco1);
     c2.load(lco2).sub(lco1);
     if (c1.dot(c1)<0.01||c2.dot(c2)<0.01) {
       l3 = l3.prev;
       continue;
     }
     c1.normalize();
     c2.normalize();
     c1.cross(c2);
     var d=c1.dot(c1);
     if (d>0.05) {
       w+=c1[2]>0.0;
       totw+=1;
     }
     l3 = l3.prev;
    }
    if (totw>0) {
      w = Math.round(w/totw);
    }
    else {
     console.log("Implement me: test edge against tesselation triangles?");
     w = wind;
    }
    if (w!=wind) {
      console.log(w, wind, colinear(lco1, cent, lco2));
      console.log(lco1, cent, lco2);
      console.log("split_face: selection lies outside of polygonal bounds");
      return null;
    }
    var b1=(l1.list==f.looplists[0]);
    var b2=(l2.list==f.looplists[0]);
    if (b1&&b2) {
      var verts1=new GArray(), verts2=new GArray();
      var l3=l1;
      while (l3!=l2.next) {
       verts1.push(l3.v);
       l3 = l3.next;
      }
      l3 = l1;
      while (l3!=l2.prev) {
       verts2.push(l3.v);
       l3 = l3.prev;
      }
      verts2.reverse();
      var vlist1=new GArray([verts1]);
      var vlist2=new GArray([verts2]);
      c = 0;
      var __iter_l = __get_iter(f.looplists[0]);
      while (1) {
       try {
        var l = __iter_l.next();
        c++;
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
      for (var i=1; i<f.looplists.length; i++) {
        var wind2=0;
        var totw=0;
        var __iter_l = __get_iter(f.looplists[i]);
        while (1) {
         try {
          var l = __iter_l.next();
          var w=winding(lco1, cos[c], lco2);
          wind2+=w;
          totw++;
          c++;
         }
         catch (_for_err) {
           if (_for_err!==StopIteration) {
             if (_do_iter_err_stacktrace)
              print_stack(_for_err);
             throw _for_err;
             break;
           }
           break;
         }
        }
        wind2 = Math.round(wind2/totw)==1;
        var vl=new GArray();
        var __iter_l = __get_iter(f.looplists[i]);
        while (1) {
         try {
          var l = __iter_l.next();
          vl.push(l.v);
         }
         catch (_for_err) {
           if (_for_err!==StopIteration) {
             if (_do_iter_err_stacktrace)
              print_stack(_for_err);
             throw _for_err;
             break;
           }
           break;
         }
        }
        if (wind2==wind) {
          vlist1.push(vl);
        }
        else {
         vlist2.push(vl);
        }
      }
      var f1=m.make_face_complex(vlist1);
      var f2=m.make_face_complex(vlist2);
      f1.no.load(f.no);
      f2.no.load(f.no);
      m.kill_face(f);
      return [f1, f2];
    }
    else {
     if (l1.list==l2.list) {
       var verts1=new GArray(), verts2=new GArray();
       var l3=l1;
       while (l3!=l2.next) {
        verts1.push(l3.v);
        l3 = l3.next;
       }
       var vlist1=new GArray([verts1]);
       var vlist2=new GArray([list(f.looplists[0])]);
       for (var i=0; i<vlist2[0].length; i++) {
         vlist2[0][i] = vlist2[0][i].v;
       }
       for (var i=1; i<f.looplists.length; i++) {
         var wind2=0;
         totw = 0;
         var __iter_l = __get_iter(f.looplists[i]);
         while (1) {
          try {
           var l = __iter_l.next();
           var w=op.winding(l1.v.co, l.v.co, l2.v.co);
           wind2+=w;
           totw++;
          }
          catch (_for_err) {
            if (_for_err!==StopIteration) {
              if (_do_iter_err_stacktrace)
               print_stack(_for_err);
              throw _for_err;
              break;
            }
            break;
          }
         }
         wind2 = Math.round(wind2/totw)==1;
         var vl=new GArray();
         var __iter_l = __get_iter(f.looplists[i]);
         while (1) {
          try {
           var l = __iter_l.next();
           vl.push(l.v);
          }
          catch (_for_err) {
            if (_for_err!==StopIteration) {
              if (_do_iter_err_stacktrace)
               print_stack(_for_err);
              throw _for_err;
              break;
            }
            break;
          }
         }
         if (wind2==wind) {
           vlist1.push(vl);
         }
         else {
          vlist2.push(vl);
         }
       }
       vlist1[0].reverse();
       var f1=m.make_face_complex(vlist1);
       var f2=m.make_face_complex(vlist2);
       f1.no.load(f.no);
       f2.no.load(f.no);
       m.kill_face(f);
       return [f1, f2];
     }
     else 
      if (!b1&&!b2) {
     }
     else {
     }
    }
  }
  return null;
 }
 this.reverse_winding = function(f) {
  var m=this.mesh;
  var __iter_list = __get_iter(f.looplists);
  while (1) {
   try {
    var list = __iter_list.next();
    var l=list.loop, lnext;
    var last_e=l.prev.e;
    do {
     m._radial_loop_remove(l.e, l);
     lnext = l.next;
     var e2=l.e;
     l.e = last_e;
     last_e = e2;
     var t=l.next;
     l.next = l.prev;
     l.prev = t;
     l = lnext;
    } while (l!=list.loop);
    do {
     m._radial_loop_insert(l.e, l);
     l = l.next;
    } while (l!=list.loop);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
 }
 this.consistent_windings = function() {
  var m=this.mesh;
  if (m.faces.length==0)
   return;
  this.recalc_normals();
  var shells=new GArray();
  var fset=new set();
  var __iter_f = __get_iter(m.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    f.index = 0;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_f = __get_iter(m.faces);
  while (1) {
   try {
    var f = __iter_f.next();
    if (f.index==1)
     continue;
    f.index = 1;
    var shell=new GArray();
    shells.push(shell);
    var stack=new GArray([f]);
    var f2;
    while (stack.length>0) {
     f2 = stack.pop();
     shell.push(f2);
     var __iter_e = __get_iter(f2.edges);
     while (1) {
      try {
       var e = __iter_e.next();
       var __iter_f3 = __get_iter(e.faces);
       while (1) {
        try {
         var f3 = __iter_f3.next();
         if (f3.index==1)
          continue;
         f3.index = 1;
         stack.push(f3);
        }
        catch (_for_err) {
          if (_for_err!==StopIteration) {
            if (_do_iter_err_stacktrace)
             print_stack(_for_err);
            throw _for_err;
            break;
          }
          break;
        }
       }
      }
      catch (_for_err) {
        if (_for_err!==StopIteration) {
          if (_do_iter_err_stacktrace)
           print_stack(_for_err);
          throw _for_err;
          break;
        }
        break;
      }
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_shell = __get_iter(shells);
  while (1) {
   try {
    var shell = __iter_shell.next();
    var dis=-1;
    var startf=null;
    var __iter_f = __get_iter(shell);
    while (1) {
     try {
      var f = __iter_f.next();
      if (dis==-1||f.center.dot(f.center)<dis) {
        dis = f.center.dot(f.center);
        startf = f;
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    var vec=new Vector3(startf.cent);
    vec.normalize();
    if (vec.dot(startf.no)<0.0) {
      this.reverse_winding(startf);
    }
    var stack=new GArray([startf]);
    var f;
    while (stack.length>0) {
     f = stack.pop();
     if (f.index==2)
      continue;
     f.index = 2;
     var flip_list=new GArray();
     var __iter_list = __get_iter(f.looplists);
     while (1) {
      try {
       var list = __iter_list.next();
       var __iter_l = __get_iter(list);
       while (1) {
        try {
         var l = __iter_l.next();
         var l2=l.radial_next;
         while (l2!=l) {
          if (l2.f!=2) {
            stack.push(l2.f);
          }
          if (l2.f.index==2) {
            l2 = l2.radial_next;
            continue;
          }
          if (l2.v==l.v)
           flip_list.push(l2.f);
          l2 = l2.radial_next;
         }
        }
        catch (_for_err) {
          if (_for_err!==StopIteration) {
            if (_do_iter_err_stacktrace)
             print_stack(_for_err);
            throw _for_err;
            break;
          }
          break;
        }
       }
      }
      catch (_for_err) {
        if (_for_err!==StopIteration) {
          if (_do_iter_err_stacktrace)
           print_stack(_for_err);
          throw _for_err;
          break;
        }
        break;
      }
     }
     var __iter_f2 = __get_iter(flip_list);
     while (1) {
      try {
       var f2 = __iter_f2.next();
       if (f2.index==2)
        continue;
       f2.index = 2;
       this.reverse_winding(f2);
      }
      catch (_for_err) {
        if (_for_err!==StopIteration) {
          if (_do_iter_err_stacktrace)
           print_stack(_for_err);
          throw _for_err;
          break;
        }
        break;
      }
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  this.recalc_normals();
 }
 this.join_faces = function(faces) {
  var mesh=this.mesh;
  var fset=new set(faces);
  var loops=new GArray();
  var holes=new GArray();
  var eset=new set();
  var __iter_f = __get_iter(fset);
  while (1) {
   try {
    var f = __iter_f.next();
    var __iter_e = __get_iter(f.edges);
    while (1) {
     try {
      var e = __iter_e.next();
      if (eset.has(e))
       continue;
      var tot=0, tot2=0;
      var __iter_f2 = __get_iter(e.faces);
      while (1) {
       try {
        var f2 = __iter_f2.next();
        tot+=fset.has(f2)!=0;
        tot2++;
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
      if (tot==1) {
        eset.add(e);
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var visit=new set();
  var __iter_e = __get_iter(eset);
  while (1) {
   try {
    var e = __iter_e.next();
    if (visit.has(e))
     continue;
    var v=e.v1;
    var e2=e;
    var loop=new GArray();
    visit.add(e);
    loop.push(v);
    do {
     var tot=0;
     var v2=v;
     tot = 0;
     var e20=e2;
     var __iter_e3 = __get_iter(v2.edges);
     while (1) {
      try {
       var e3 = __iter_e3.next();
       if (e3==e20)
        continue;
       if (eset.has(e3)) {
         if (v==v2) {
           e2 = e3;
           v = e2.other_vert(v);
         }
         tot++;
       }
      }
      catch (_for_err) {
        if (_for_err!==StopIteration) {
          if (_do_iter_err_stacktrace)
           print_stack(_for_err);
          throw _for_err;
          break;
        }
        break;
      }
     }
     if (tot!=1) {
       console.log("tot ", tot);
       throw new TopoError("Invalid selection "+tot);
     }
     if (visit.has(e2))
      break;
     loop.push(v);
     visit.add(e2);
    } while (1);
    if (loop.length<3) {
      throw new TopoError("Invalid Selection");
    }
    console.log("loop len: ", loop.length);
    var len=0.0;
    for (var i=0; i<loop.length; i++) {
      len+=loop[i].co.vectorDistance(loop[(i+1)%loop.length].co);
    }
    console.log(len);
    loops.push([len, loop]);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  console.log("esl", eset.length);
  console.log("loopsl", loops.length);
  var bound=0;
  var len=0;
  for (var i=0; i<loops.length; i++) {
    if (loops[i][0]>len) {
      len = loops[i][0];
      bound = i;
    }
  }
  console.log("bound: ", bound, loops[bound][0]);
  var v1=loops[bound][1][0];
  var v2=loops[bound][1][1];
  var rev=false;
  var __iter_l = __get_iter(v1.loops);
  while (1) {
   try {
    var l = __iter_l.next();
    if (fset.has(l.f)) {
      if (l.v==v1&&l.next.v!=v2) {
        rev = true;
      }
      if (l.prev.v==v1&&l.v!=v2) {
        rev = true;
      }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_l = __get_iter(v2.loops);
  while (1) {
   try {
    var l = __iter_l.next();
    if (fset.has(l.f)) {
      if (l.next.v==v2&&l.v!=v1) {
        rev = true;
      }
      if (l.v==v2&&l.prev.v!=v1) {
        rev = true;
      }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  if (rev) {
    loops[bound][1].reverse();
  }
  var vset=new set();
  eset = new set();
  var __iter_f = __get_iter(fset);
  while (1) {
   try {
    var f = __iter_f.next();
    var __iter_l = __get_iter(f.loops);
    while (1) {
     try {
      var l = __iter_l.next();
      var tot1=0, tot2=0;
      var e=l.e;
      var __iter_f2 = __get_iter(e.faces);
      while (1) {
       try {
        var f2 = __iter_f2.next();
        tot1+=fset.has(f2)!=0;
        tot2++;
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
      if (tot1==tot2)
       eset.add(e);
      var v=l.v;
      tot1 = tot2 = 0;
      var __iter_l2 = __get_iter(v.loops);
      while (1) {
       try {
        var l2 = __iter_l2.next();
        tot1+=fset.has(l2.f)!=0;
        tot2++;
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
      if (tot1==tot2) {
        vset.add(v);
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var vlooplists=new GArray([loops[bound][1]]);
  for (var i=0; i<loops.length; i++) {
    if (i==bound)
     continue;
    console.log(loops[i]);
    vlooplists.push(loops[i][1]);
  }
  console.log(vlooplists);
  var nf=mesh.make_face_complex(vlooplists);
  var totsmooth=0, totsolid=0;
  var __iter_f = __get_iter(fset);
  while (1) {
   try {
    var f = __iter_f.next();
    if (f.flag&Flags.SELECT)
     mesh.faces.select(nf, true);
    if (f.flag&Flags.SHADE_SMOOTH)
     totsmooth++;
    else 
     totsolid++;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  if (totsmooth>totsolid)
   nf.flag|=Flags.SHADE_SMOOTH;
  var __iter_f = __get_iter(fset);
  while (1) {
   try {
    var f = __iter_f.next();
    mesh.kill_face(f);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_e = __get_iter(eset);
  while (1) {
   try {
    var e = __iter_e.next();
    mesh.kill_edge(e);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_v = __get_iter(vset);
  while (1) {
   try {
    var v = __iter_v.next();
    mesh.kill_vert(v);
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
 }
 this.duplicate_geometry = function(geometry, deselect_old) {
  var mesh=this.mesh;
  if (deselect_old==undefined)
   deselect_old = false;
  var vset, eset, fset;
  fset = new set();
  eset = new set();
  vset = new set();
  var __iter_e = __get_iter(geometry);
  while (1) {
   try {
    var e = __iter_e.next();
    if (e.type==MeshTypes.FACE) {
      fset.add(e);
    }
    else 
     if (e.type==MeshTypes.EDGE) {
      eset.add(e);
    }
    else 
     if (e.type==MeshTypes.VERT) {
      vset.add(e);
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var verts=new GArray();
  var edges=new GArray();
  var faces=new GArray();
  var vi=0;
  var ei=0;
  var fi=0;
  var __iter_v = __get_iter(vset);
  while (1) {
   try {
    var v = __iter_v.next();
    verts.push(v);
    v.index = vi++;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_e = __get_iter(eset);
  while (1) {
   try {
    var e = __iter_e.next();
    edges.push(e);
    e.index = ei++;
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_f = __get_iter(fset);
  while (1) {
   try {
    var f = __iter_f.next();
    faces.push(f);
    f.index = fi++;
    var __iter_loop = __get_iter(f.looplists);
    while (1) {
     try {
      var loop = __iter_loop.next();
      var __iter_l = __get_iter(loop);
      while (1) {
       try {
        var l = __iter_l.next();
        var v=l.v;
        if (!vset.has(v)) {
          verts.push(v);
          v.index = vi++;
          vset.add(v);
        }
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    var __iter_e = __get_iter(f.edges);
    while (1) {
     try {
      var e = __iter_e.next();
      if (!eset.has(e)) {
        edges.push(e);
        e.index = ei++;
        eset.add(e);
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  var __iter_e = __get_iter(eset);
  while (1) {
   try {
    var e = __iter_e.next();
    if (!vset.has(e.v1)) {
      e.v1.index = vi++;
      verts.push(e.v1);
      vset.add(e.v1);
    }
    if (!vset.has(e.v2)) {
      e.v2.index = vi++;
      verts.push(e.v2);
      vset.add(e.v2);
    }
   }
   catch (_for_err) {
     if (_for_err!==StopIteration) {
       if (_do_iter_err_stacktrace)
        print_stack(_for_err);
       throw _for_err;
       break;
     }
     break;
   }
  }
  for (var i=0; i<verts.length; i++) {
    var v=verts[i];
    var nv=mesh.make_vert(v.co, v.no);
    mesh.copy_vert_data(nv, v);
    verts[i] = nv;
  }
  for (var i=0; i<edges.length; i++) {
    var e=edges[i];
    var ne=mesh.make_edge(verts[e.v1.index], verts[e.v2.index]);
    edges[i] = ne;
    mesh.copy_edge_data(ne, e);
  }
  for (var i=0; i<faces.length; i++) {
    f = faces[i];
    var vlists=new GArray();
    var __iter_loop = __get_iter(f.looplists);
    while (1) {
     try {
      var loop = __iter_loop.next();
      var vs=new GArray();
      vlists.push(vs);
      vs.length = 0;
      var __iter_l = __get_iter(loop);
      while (1) {
       try {
        var l = __iter_l.next();
        vs.push(verts[l.v.index]);
       }
       catch (_for_err) {
         if (_for_err!==StopIteration) {
           if (_do_iter_err_stacktrace)
            print_stack(_for_err);
           throw _for_err;
           break;
         }
         break;
       }
      }
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    var nf=mesh.make_face_complex(vlists);
    var iter1=f.loops.__iterator__();
    var iter2=nf.loops.__iterator__();
    mesh.copy_face_data(nf, f);
    while (1) {
     try {
      var l1=iter1.next();
      var l2=iter2.next();
      mesh.copy_loop_data(l2, l1);
     }
     catch (err) {
       if (err!=StopIteration) {
         throw err;
       }
       else {
        break;
       }
     }
    }
  }
  if (deselect_old) {
    var __iter_v = __get_iter(vset);
    while (1) {
     try {
      var v = __iter_v.next();
      mesh.verts.select(v, false);
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    var __iter_e = __get_iter(eset);
    while (1) {
     try {
      var e = __iter_e.next();
      mesh.edges.select(e, false);
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
    var __iter_f = __get_iter(fset);
    while (1) {
     try {
      var f = __iter_f.next();
      mesh.faces.select(f, false);
     }
     catch (_for_err) {
       if (_for_err!==StopIteration) {
         if (_do_iter_err_stacktrace)
          print_stack(_for_err);
         throw _for_err;
         break;
       }
       break;
     }
    }
  }
 }
}

  j = 0;
  for (var tst in new range2(2, 8)) {
    if (_do_frame_debug) console.log(tst);
    if (j > 10)
      break;
    j++;
  }
  </script>
  </html>
  